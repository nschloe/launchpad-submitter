#!/usr/bin/env python3
# -*- coding: utf-8 -*-
#
import argparse
import git
import os
import shutil
import tempfile


def update_patches(directory):
    '''debuild's patch apply doesn't allow fuzz, but fuzz is often what happens
    when applying a Debian patch to the master branch. `patch` itself is more
    robust, so use that here to update the Debian patches.
    '''
    debian_dir = os.path.join(directory, 'debian')
    if os.path.isfile(os.path.join(debian_dir, 'patches', 'ubuntu.series')):
        series = os.path.join(debian_dir, 'patches', 'ubuntu.series')
    elif os.path.isfile(os.path.join(debian_dir, 'patches', 'series')):
        series = os.path.join(debian_dir, 'patches', 'series')
    else:
        return

    with open(series, 'r') as f:
        content = f.readlines()

    if content:
        try:
            repo = git.Repo(directory)
        except git.exc.InvalidGitRepositoryError:
            raise RuntimeError('Directory %s is not Git-managed.' % directory)

        repo.git.checkout('.')

        tmp_dir = tempfile.mkdtemp()
        filenames = []
        for line in content:
            filename = line.strip()
            if filename[0] == '#':
                # skip commented-out lines
                continue
            filenames.append(filename)

            print('  Updating %s...' % filename)
            repo.git.checkout('.')
            # apply the patch
            patch_path = os.path.join(debian_dir, 'patches', filename)
            repo.git.apply(patch_path)
            # write diff to temporary file
            with open(os.path.join(tmp_dir, filename), 'w') as f:
                f.write(repo.git.diff())
                f.write('\n')

        # move the files back over to debian/patches
        repo.git.checkout('.')
        for filename in filenames:
            shutil.move(
                    os.path.join(tmp_dir, filename),
                    os.path.join(debian_dir, 'patches', filename)
                    )

    return


def _parse_cmd_arguments():
    parser = argparse.ArgumentParser(
            description='Update patches builds to launchpad.'
            )
    parser.add_argument(
            '--source', '-s',
            type=str,
            required=True,
            help='source directory'
            )
    parser.add_argument(
            '--debian', '-d',
            type=str,
            required=True,
            help='debian/ directory'
            )
    parser.add_argument(
            '--out', '-o',
            type=str,
            required=True,
            help='output directory'
            )
    return parser.parse_args()


def create_repo(source, debian, out):
    shutil.copytree(source, out)
    shutil.copytree(debian, os.path.join(out, 'debian'))

    # Remove git-related entities to ensure a smooth creation of the repo later
    try:
        shutil.rmtree(os.path.join(out, '.git'))
        os.remove(os.path.join(out, '.gitignore'))
        shutil.rmtree(os.path.join(out, 'debian', '.git'))
        os.remove(os.path.join(out, 'debian', '.gitignore'))
    except FileNotFoundError:
        pass

    repo = git.Repo.init(out)
    repo.index.add('*')
    repo.index.commit('import source, debian/')

    update_patches(out)
    repo.git.add(update=True)
    repo.index.commit('updated patches')

    return


if __name__ == '__main__':
    args = _parse_cmd_arguments()
    create_repo(args.source, args.debian, args.out)
