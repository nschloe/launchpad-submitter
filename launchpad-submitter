#!/usr/bin/env python3
# -*- coding: utf-8 -*-
'''
Automatically create tarball and submit it to launchpad.
'''

import os
import subprocess
import datetime
import shutil
import glob
import yaml


def _main():
    args = _parse_cmd_arguments()

    # Retrieve the directory of this script
    basedir = os.path.dirname(os.path.realpath(__file__))

    print('Fetching updates...')
    os.chdir(args.source_dir)
    subprocess.check_call(['git', 'pull'])
    os.chdir(args.debian_dir)
    subprocess.check_call(['git', 'pull'])
    print('done.')

    os.chdir(args.source_dir)
    source_revision = subprocess.check_output(['git',
                                               'rev-parse',
                                               'HEAD'
                                               ]).decode('utf-8').strip()

    os.chdir(args.debian_dir)
    debian_revision = subprocess.check_output(['git',
                                               'rev-parse',
                                               'HEAD'
                                               ]).decode('utf-8').strip()

    # File to store the HEAD command of the last push.
    revision_file = os.path.join(
        os.path.expanduser('~'),
        '.%s-submit-unstable' % args.name
        )
    try:
        revision_data = yaml.load_all(open(revision_file, 'r'))
        revision_dicts = []
        for doc in revision_data:
            revision_dicts.append(doc)
        is_uptodate = (
            source_revision == revision_dicts[0]['source revision']
            and debian_revision == revision_dicts[0]['debian revision']
            )
    except IOError:
        # If no file is found, assume that we are not up-to-date.
        is_uptodate = False

    if is_uptodate:
        print('Latest version already submitted to launchpad.')
        return 0

    # Get package version.
    # Actually quite dangerous. The user may inject malicious code here.
    os.chdir(args.source_dir)
    package_version = subprocess.getoutput(args.version_getter).strip()

    # Create a day-to-day version number of the form 4.3.1.2~20121123.
    today_str = datetime.date.today().strftime('%Y%m%d')
    #today_str = '20140508'
    version = package_version + '~' + today_str

    # Create the tarball.
    tarball_path = os.path.join('/tmp/', args.name + '.tar.gz')
    prefix = args.name + '-' + version
    print('Creating new archive %s...' % tarball_path)
    if os.path.isfile(tarball_path):
        os.remove(tarball_path)
    # Append the "/" to $PREFIX, otherwise this may be interpreted as an
    # ordinary filename-prefix.
    subprocess.check_call(['git', 'archive',
                           'master',
                           '--prefix=%s/' % prefix,
                           '--format=tar.gz',
                           '--output=%s' % tarball_path
                           ])
    print('done.')

    for ubuntu_release in args.ubuntu_releases:
        # Create empty directory of the form
        #     /tmp/trilinos/trusty/
        release_dir = os.path.join('/tmp', args.name, ubuntu_release)
        if os.path.exists(release_dir):
            shutil.rmtree(release_dir)
        # Use Python3's makedirs for recursive creation
        os.makedirs(release_dir, exist_ok=True)

        # Copy source tarball to
        #     /tmp/trilinos/trusty/trilinos_4.3.1.2~20121123.tar.gz
        tarball_name = '%s_%s.orig.tar.gz' % (args.name, version)
        shutil.copy2(tarball_path, os.path.join(release_dir, tarball_name))
        # Unpack the tarball
        os.chdir(release_dir)
        subprocess.check_call(['tar', 'xf', tarball_name])

        ## Cleaning Debian directory to avoid copy errors with invalid
        ## symlinks.
        # TODO don't clean to make sure not to accidentally delete patches
        #os.chdir(args.debian_dir)
        #subprocess.check_call(['git', 'clean', '-f', '-d'])

        # Copy over the debian folder to
        #     /tmp/trilinos/trusty/debian/
        os.chdir(release_dir)
        shutil.copytree(args.debian_dir, os.path.join(prefix, 'debian'))

        # Patch the sources if necessary
        patch_file = os.path.join(basedir,
                                  args.name + '-ubuntu-backports',
                                  ubuntu_release + '.patch'
                                  )
        if os.path.isfile(patch_file):
            os.chdir(prefix)
            subprocess.check_call('patch -p1 < ' + patch_file, shell=True)

        # Optionally add extra patches.
        if args.extra_patches_dir:
            if os.path.isabs(args.extra_patches_dir):
                source_dir = args.extra_patches_dir
            else:
                source_dir = os.path.join(basedir, args.extra_patches_dir)
            os.chdir(release_dir)
            dest_dir = os.path.join(prefix, 'debian', 'patches/')
            assert(os.path.isdir(dest_dir))
            files = glob.iglob(os.path.join(source_dir, "*.patch"))
            for file in files:
                if os.path.isfile(file):
                    shutil.copy2(file, dest_dir)
            # Concatenate the series files
            source_file = os.path.join(source_dir, 'series')
            dest_file = os.path.join(dest_dir, 'series')
            with open(dest_file, 'a') as outfile:
                with open(source_file) as infile:
                    outfile.write(infile.read())

        # Use the `-` as a separator (instead of `~` as it's often used) to
        # make sure that ${UBUNTU_RELEASE}x isn't part of the name. This
        # makes it possible to increment `x` and have launchpad recognize
        # it as a new version.
        full_version = version + '-' + ubuntu_release + args.resubmission
        if args.slot:
            chlog_version = args.slot + ':' + full_version
        else:
            chlog_version = full_version

        # Override changelog
        utcnow = datetime.datetime.utcnow()
        changelog = open(os.path.join(prefix, 'debian/changelog'), 'w')
        changelog.write('''%s (%s) %s; urgency=low

  * Initial release

 -- Nico SchlÃ¶mer <nico.schloemer@gmail.com>  %s'''
                        % (args.name, chlog_version,
                           ubuntu_release,
                           utcnow.strftime('%a, %d %b %Y %T +0000')
                           ))
        changelog.close()

        # Call debuild, the actual workhorse
        os.chdir(prefix)
        subprocess.check_call(['debuild',
                               '-p%s' % os.path.join(basedir, 'mygpg'),
                               '-S'
                               ])

        # Submit to launchpad.
        os.chdir(os.pardir)
        for ppa in args.ppas:
            print()
            print('Uploading to PPA %s...' % ppa)
            print()
            subprocess.check_call([
                'dput',
                'ppa:%s' % ppa,
                '%s_%s_source.changes' % (args.name, full_version)
                ])
            # Remove the upload file so we can upload again to another ppa
            os.remove('%s_%s_source.ppa.upload'
                      % (args.name, full_version)
                      )

    if args.ppas:
        # Store which revision we're pushing so we don't do it twice.
        data = {
            'source revision': source_revision,
            'debian revision': debian_revision
            }
        with open(revision_file, 'w') as outfile:
            outfile.write(yaml.dump(data, default_flow_style=False))

    return


def _parse_cmd_arguments():
    import argparse
    parser = argparse.ArgumentParser(description='Submit builds to launchpad.')
    parser.add_argument(
        '-n', '--name',
        type=str,
        required=True,
        help='package name'
        )
    parser.add_argument(
        '-r', '--resubmission',
        default=1,
        help='resubmission index (default: 1)'
        )
    parser.add_argument(
        '-s', '--source-dir',
        required=True,
        help='Directory of the package source'
        )
    parser.add_argument(
        '-d', '--debian-dir',
        required=True,
        help='Directory of the debian/ source'
        )
    parser.add_argument(
        '-u', '--ubuntu-releases',
        help='Ubuntu releases to build for',
        required=True,
        nargs='+'
        )
    parser.add_argument(
        '-p', '--ppas',
        help='PPAs to submit to',
        type=str,
        nargs='+',
        required=True
        )
    parser.add_argument(
        '-v', '--version-getter',
        help='Shell command for extracting the version number',
        type=str,
        required=True
        )
    parser.add_argument(
        '-l', '--slot',
        help='Slot for the package (default: None)',
        default=None,
        type=str
        )
    parser.add_argument(
        '-a', '--extra-patches-dir',
        help='Optional extra patches directory (default: None)',
        default=None,
        type=str
        )
    parser.add_argument(
        '-b', '--backports-dir',
        help=('Directory that contains patches for older Ubuntu versions '
              '(default: None)'),
        default=None,
        type=str
        )
    return parser.parse_args()


if __name__ == '__main__':
    _main()
