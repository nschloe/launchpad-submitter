#!/usr/bin/env python3
# -*- coding: utf-8 -*-
'''
Automatically create tarball and submit it to launchpad.
'''

import argparse
import datetime
import git
# import git_archive_all
import os
import shutil
import subprocess
import sys
import tarfile
import yaml


def _run(command):
    '''Runs a given command on the command line and returns its output.
    '''
    # print(command)
    process = subprocess.Popen(
        command,
        shell=True,
        stdout=subprocess.PIPE,
        stderr=subprocess.PIPE,
        close_fds=True
        )
    output = process.stdout.read()[:-1]
    ret = process.wait()

    if ret != 0:
        sys.exit(
            '\nERROR: The command \n\n%s\n\nreturned a nonzero '
            'exit status. The error message is \n\n%s\n\n'
            'Abort.\n'
            % (command, process.stderr.read()[:-1])
            )
    return output


def _main():

    args = _parse_cmd_arguments()

    # Retrieve the directory of this script
    basedir = os.path.dirname(os.path.realpath(__file__))

    # Get Debian info.
    if args.debian_dir:
        try:
            debian_repo = git.Repo(args.debian_dir + '../')
            debian_revision = str(debian_repo.rev_parse('HEAD'))
        except git.exc.InvalidGitRepositoryError:
            try:
                debian_repo = git.Repo(args.debian_dir)
                print('Fetching updates...')
                debian_repo.remotes.origin.pull()
                print('done.')
                debian_revision = str(debian_repo.rev_parse('HEAD'))
            except git.exc.InvalidGitRepositoryError:
                debian_revision = None
    else:
        debian_revision = None

    try:
        source_repo = git.Repo(args.source_dir)
    except git.exc.InvalidGitRepositoryError:
        source_repo = None

    has_tmp_commit = False
    if source_repo:
        print('Fetching updates...')
        source_repo.remotes.origin.pull()
        print('done.')
        # Build a version.
        if source_repo.is_dirty():
            if args.force:
                index = source_repo.index
                # Add all files with uncommitted changes to the index
                index.add([diff.a_blob.path for diff in index.diff(None)])
                # commit
                index.commit(
                    'temp commit',
                    author=git.Actor('launchpad-submitter', 'ls@wind')
                    )
                has_tmp_commit = True  # for later undoing of the commit
            else:
                raise RuntimeError(
                    'Uncommitted changes in the source repo. '
                    'Use -f to submit nonetheless.'
                    )
        source_revision = str(source_repo.rev_parse('HEAD'))
    else:
        source_revision = None

    if args.submit_hashes_file and os.path.isfile(args.submit_hashes_file):
        # File to store the HEAD command of the last push.
        revision_data = yaml.load_all(open(args.submit_hashes_file, 'r'))
        revision_dicts = []
        for doc in revision_data:
            revision_dicts.append(doc)
        is_uptodate = (
            source_revision == revision_dicts[0]['source revision'] and
            (not debian_revision or
                debian_revision == revision_dicts[0]['debian revision'])
            )

        if is_uptodate and not args.force:
            print('Latest version already submitted to launchpad.')
            return 0

    # Create a day-to-day version number of the form 4.3.1.2~201211230030.
    # For launchpad to accept new submissions, the string has to increment.
    now_str = datetime.datetime.now().strftime('%Y%m%d%H%M')
    version = args.version + '~' + now_str

    # Create the tarball.
    tarball_path = os.path.join('/tmp/', args.name + '.tar.gz')
    prefix = args.name + '-' + version
    print('Creating new archive %s...' % tarball_path)
    if source_repo:
        if source_repo.submodules:
            # Use <https://github.com/Kentzo/git-archive-all>
            os.chdir(args.source_dir)
            # Append the '/' to $PREFIX, otherwise this may be interpreted as
            # an ordinary filename-prefix.
            subprocess.check_output(
                'git-archive-all --prefix=%s %s' %
                (prefix + '/', tarball_path)
                )
        else:
            fh = open(tarball_path, 'wb')
            source_repo.archive(
                    fh,
                    prefix=prefix + '/',
                    format='tar.gz'
                    )
            fh.close()
    else:
        # Not a Git repo
        with tarfile.open(tarball_path, 'w:gz') as tar:
            tar.add(args.source_dir, arcname=prefix)

    print('done.')

    if has_tmp_commit:
        # undo temporary commit aka `git reset HEAD^`
        source_repo.git.reset('HEAD^')

    for ubuntu_release in args.ubuntu_releases:
        # Create empty directory of the form
        #     /tmp/trilinos/trusty/
        release_dir = os.path.join('/tmp', args.name, ubuntu_release)
        if os.path.exists(release_dir):
            shutil.rmtree(release_dir)
        # Use Python3's makedirs for recursive creation
        os.makedirs(release_dir, exist_ok=True)

        # Copy source tarball to
        #     /tmp/trilinos/trusty/trilinos_4.3.1.2~20121123.tar.gz
        tarball_name = '%s_%s.orig.tar.gz' % (args.name, version)
        shutil.copy2(tarball_path, os.path.join(release_dir, tarball_name))
        # Unpack the tarball
        os.chdir(release_dir)
        tar = tarfile.open(tarball_name)
        tar.extractall()
        tar.close()

        # # Cleaning Debian directory to avoid copy errors with invalid
        # # symlinks.
        #  TODO don't clean to make sure not to accidentally delete patches
        # os.chdir(args.debian_dir)
        # subprocess.check_call(['git', 'clean', '-f', '-d'])

        # Copy over the debian folder to
        #     /tmp/trilinos/trusty/debian/
        os.chdir(release_dir)
        if args.debian_dir:
            shutil.copytree(
                    args.debian_dir,
                    os.path.join(prefix, 'debian')
                    )
        # else:
        #     # assert that the source tree contains a folder 'debian'
        #     assert(os.path.isdir(os.path.join(args.source_dir, 'debian')))

        assert os.path.isdir(os.path.join(prefix, 'debian'))

        if args.debian_prepare:
            print('Execute \'%s\'...' % args.debian_prepare)
            os.chdir(os.path.join(prefix, 'debian'))
            _run(args.debian_prepare)

        os.chdir(release_dir)

        # Patch the sources if necessary
        patch_file = os.path.join(basedir,
                                  args.name + '-ubuntu-backports',
                                  ubuntu_release + '.patch'
                                  )
        if os.path.isfile(patch_file):
            os.chdir(prefix)
            subprocess.check_call('patch -p1 < ' + patch_file, shell=True)

        # Use the `-` as a separator (instead of `~` as it's often used) to
        # make sure that ${UBUNTU_RELEASE}x isn't part of the name. This makes
        # it possible to increment `x` and have launchpad recognize it as a new
        # version.
        full_version = version + '-' + ubuntu_release + str(args.resubmission)
        if args.slot:
            chlog_version = args.slot + ':' + full_version
        else:
            chlog_version = full_version

        # Override changelog
        utcnow = datetime.datetime.utcnow()
        changelog = open(os.path.join(prefix, 'debian/changelog'), 'w')
        changelog.write('''%s (%s) %s; urgency=low

  * Initial release

 -- Nico SchlÃ¶mer <nico.schloemer@gmail.com>  %s'''
                        % (args.name, chlog_version,
                           ubuntu_release,
                           utcnow.strftime('%a, %d %b %Y %T +0000')
                           ))
        changelog.close()

        # Call debuild, the actual workhorse
        os.chdir(prefix)
        subprocess.check_call(
                ['debuild', '-p%s' % os.path.join(basedir, 'mygpg'), '-S',
                 '--lintian-opts', '-EvIL', '+pedantic']
                )

        # Submit to launchpad.
        os.chdir(os.pardir)
        if not args.dry:
            for ppa in args.ppas:
                print()
                print('Uploading to PPA %s...' % ppa)
                print()
                subprocess.check_call([
                    'dput',
                    'ppa:%s' % ppa,
                    '%s_%s_source.changes' % (args.name, full_version)
                    ])
                # Remove the upload file so we can upload again to another ppa
                os.remove('%s_%s_source.ppa.upload'
                          % (args.name, full_version)
                          )

    if args.submit_hashes_file:
        # Store which revision we're pushing so we don't do it twice.
        data = {
            'source revision': source_revision,
            'debian revision': debian_revision
            }
        with open(args.submit_hashes_file, 'w') as outfile:
            outfile.write(yaml.dump(data, default_flow_style=False))

    return


def _parse_cmd_arguments():
    parser = argparse.ArgumentParser(description='Submit builds to launchpad.')
    parser.add_argument(
        '-n', '--name',
        type=str,
        required=True,
        help='package name'
        )
    parser.add_argument(
        '-r', '--resubmission',
        default=1,
        help='resubmission index (default: 1)'
        )
    parser.add_argument(
        '-s', '--source-dir',
        required=True,
        help='Directory of the package source'
        )
    parser.add_argument(
        '-d', '--debian-dir',
        help='Directory of the debian/ source'
        )
    parser.add_argument(
        '-u', '--ubuntu-releases',
        help='Ubuntu releases to build for',
        required=True,
        nargs='+'
        )
    parser.add_argument(
        '-p', '--ppas',
        help='PPAs to submit to',
        type=str,
        nargs='+',
        required=True
        )
    parser.add_argument(
        '-v', '--version',
        help='Package version',
        type=str,
        required=True
        )
    parser.add_argument(
        '-e', '--debian-prepare',
        help='Shell command to execute in the debian folder before processing',
        type=str
        )
    parser.add_argument(
        '-l', '--slot',
        help='Slot for the package (default: None)',
        default=None,
        type=str
        )
    parser.add_argument(
        '-z', '--submit-hashes-file',
        help='File in which to store the submit hashes',
        type=str,
        default=None
        )
    parser.add_argument(
        '-f', '--force',
        help='Force submission even if build is already uploaded',
        action='store_true',
        default=False
        )
    parser.add_argument(
        '-y', '--dry',
        help='Dry run (do everything but the upload)',
        action='store_true',
        default=False
        )
    return parser.parse_args()


if __name__ == '__main__':
    _main()
