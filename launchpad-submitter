#!/usr/bin/env python3
# -*- coding: utf-8 -*-
'''
Automatically create tarball and submit it to launchpad.
'''

import os
import subprocess
import datetime
import shutil
import glob
import yaml


def _main():
    # Get the directory of this script. This has to be done before any chdir
    # command.
    #this_dir = os.path.dirname(os.path.realpath(__file__))

    args = _parse_cmd_arguments()

    # Retrieve the directory of this script
    basedir = os.path.dirname(os.path.realpath(__file__))

    print('Fetching updates...')
    os.chdir(args.source_dir)
    subprocess.check_call(['git', 'pull'])
    #os.chdir(args.debian_dir)
    #subprocess.check_call(['git', 'pull'])
    print('done.')

    os.chdir(args.source_dir)
    source_revision = subprocess.check_output(['git',
                                               'rev-parse',
                                               'HEAD'
                                               ]).decode('utf-8').strip()

    os.chdir(args.debian_dir)
    debian_revision = subprocess.check_output(['git',
                                               'rev-parse',
                                               'HEAD'
                                               ]).decode('utf-8').strip()

    # File to store the HEAD command of the last push.
    revision_data = yaml.load_all(open(args.submit_hashes_file, 'r'))
    revision_dicts = []
    for doc in revision_data:
        revision_dicts.append(doc)
    is_uptodate = (
        source_revision == revision_dicts[0]['source revision']
        and debian_revision == revision_dicts[0]['debian revision']
        )

    if is_uptodate:
        print('Latest version already submitted to launchpad.')
        return 0

    # Get package version.
    # Actually quite dangerous. The user may inject malicious code here.
    os.chdir(args.source_dir)
    package_version = subprocess.getoutput(args.version_getter).strip()

    # Create a day-to-day version number of the form 4.3.1.2~20121123.
    today_str = datetime.date.today().strftime('%Y%m%d')
    #today_str = '20150124'
    version = package_version + '~' + today_str

    # Create the tarball.
    tarball_path = os.path.join('/tmp/', args.name + '.tar.gz')
    prefix = args.name + '-' + version
    print('Creating new archive %s...' % tarball_path)
    if os.path.isfile(tarball_path):
        os.remove(tarball_path)
    # Append the '/' to $PREFIX, otherwise this may be interpreted as an
    # ordinary filename-prefix.
    subprocess.check_call([
        'git', 'archive',
        'master',
        '--prefix=%s/' % prefix,
        '--format=tar.gz',
        '--output=%s' % tarball_path
        ])
    print('done.')

    for ubuntu_release in args.ubuntu_releases:
        # Create empty directory of the form
        #     /tmp/trilinos/trusty/
        release_dir = os.path.join('/tmp', args.name, ubuntu_release)
        if os.path.exists(release_dir):
            shutil.rmtree(release_dir)
        # Use Python3's makedirs for recursive creation
        os.makedirs(release_dir, exist_ok=True)

        # Copy source tarball to
        #     /tmp/trilinos/trusty/trilinos_4.3.1.2~20121123.tar.gz
        tarball_name = '%s_%s.orig.tar.gz' % (args.name, version)
        shutil.copy2(tarball_path, os.path.join(release_dir, tarball_name))
        # Unpack the tarball
        os.chdir(release_dir)
        subprocess.check_call(['tar', 'xf', tarball_name])

        ## Cleaning Debian directory to avoid copy errors with invalid
        ## symlinks.
        # TODO don't clean to make sure not to accidentally delete patches
        #os.chdir(args.debian_dir)
        #subprocess.check_call(['git', 'clean', '-f', '-d'])

        # Copy over the debian folder to
        #     /tmp/trilinos/trusty/debian/
        os.chdir(release_dir)
        shutil.copytree(args.debian_dir, os.path.join(prefix, 'debian'))

        # Patch the sources if necessary
        patch_file = os.path.join(basedir,
                                  args.name + '-ubuntu-backports',
                                  ubuntu_release + '.patch'
                                  )
        if os.path.isfile(patch_file):
            os.chdir(prefix)
            subprocess.check_call('patch -p1 < ' + patch_file, shell=True)

        # Optionally remove patches.
        if args.patches_blacklist:
            for sfile in ['patches/series', 'patches/ubuntu.series']:
                series_file = os.path.join(prefix, 'debian', sfile)
                if not os.path.isfile(series_file):
                    continue
                # list copies: <http://stackoverflow.com/a/2612815/353337>
                tmp_blacklist = list(args.patches_blacklist)
                tmp_file = os.path.join('/tmp/series.new')
                with open(series_file, 'r') as input:
                    with open(tmp_file, 'w') as output:
                        for line in input:
                            try:
                                k = tmp_blacklist.index(line.strip())
                                tmp_blacklist.pop(k)
                            except ValueError:
                                output.write(line)
                if tmp_blacklist:
                    raise ValueError('The patches %r are not in debian/series.'
                                     % tmp_blacklist
                                     )
                shutil.copy2(tmp_file, series_file)

        # Optionally add extra patches.
        if args.extra_patches_dir:
            if os.path.isabs(args.extra_patches_dir):
                source_dir = args.extra_patches_dir
            else:
                source_dir = os.path.join(basedir, args.extra_patches_dir)
            os.chdir(release_dir)
            dest_dir = os.path.join(prefix, 'debian', 'patches/')
            assert(os.path.isdir(dest_dir))
            files = glob.iglob(os.path.join(source_dir, '*.patch'))
            for file in files:
                if os.path.isfile(file):
                    shutil.copy2(file, dest_dir)
            # Concatenate the series files
            source_file = os.path.join(source_dir, 'series')
            dest_file = os.path.join(dest_dir, 'series')
            with open(dest_file, 'a') as outfile:
                with open(source_file) as infile:
                    outfile.write(infile.read())

        # Use the `-` as a separator (instead of `~` as it's often used) to
        # make sure that ${UBUNTU_RELEASE}x isn't part of the name. This
        # makes it possible to increment `x` and have launchpad recognize
        # it as a new version.
        full_version = version + '-' + ubuntu_release + args.resubmission
        if args.slot:
            chlog_version = args.slot + ':' + full_version
        else:
            chlog_version = full_version

        # Override changelog
        utcnow = datetime.datetime.utcnow()
        changelog = open(os.path.join(prefix, 'debian/changelog'), 'w')
        changelog.write('''%s (%s) %s; urgency=low

  * Initial release

 -- Nico Schl√∂mer <nico.schloemer@gmail.com>  %s'''
                        % (args.name, chlog_version,
                           ubuntu_release,
                           utcnow.strftime('%a, %d %b %Y %T +0000')
                           ))
        changelog.close()

        # Call debuild, the actual workhorse
        os.chdir(prefix)
        subprocess.check_call(['debuild',
                               '-p%s' % os.path.join(basedir, 'mygpg'),
                               '-S'
                               ])

        # Submit to launchpad.
        os.chdir(os.pardir)
        for ppa in args.ppas:
            print()
            print('Uploading to PPA %s...' % ppa)
            print()
            subprocess.check_call([
                'dput',
                'ppa:%s' % ppa,
                '%s_%s_source.changes' % (args.name, full_version)
                ])
            # Remove the upload file so we can upload again to another ppa
            os.remove('%s_%s_source.ppa.upload'
                      % (args.name, full_version)
                      )

    if args.ppas:
        # Store which revision we're pushing so we don't do it twice.
        data = {
            'source revision': source_revision,
            'debian revision': debian_revision
            }
        with open(args.submit_hashes_file, 'w') as outfile:
            outfile.write(yaml.dump(data, default_flow_style=False))

    return


def _parse_cmd_arguments():
    import argparse
    parser = argparse.ArgumentParser(description='Submit builds to launchpad.')
    parser.add_argument(
        '-n', '--name',
        type=str,
        required=True,
        help='package name'
        )
    parser.add_argument(
        '-r', '--resubmission',
        default=1,
        help='resubmission index (default: 1)'
        )
    parser.add_argument(
        '-s', '--source-dir',
        required=True,
        help='Directory of the package source'
        )
    parser.add_argument(
        '-d', '--debian-dir',
        required=True,
        help='Directory of the debian/ source'
        )
    parser.add_argument(
        '-u', '--ubuntu-releases',
        help='Ubuntu releases to build for',
        required=True,
        nargs='+'
        )
    parser.add_argument(
        '-p', '--ppas',
        help='PPAs to submit to',
        type=str,
        nargs='+',
        required=True
        )
    parser.add_argument(
        '-v', '--version-getter',
        help='Shell command for extracting the version number',
        type=str,
        required=True
        )
    parser.add_argument(
        '-l', '--slot',
        help='Slot for the package (default: None)',
        default=None,
        type=str
        )
    parser.add_argument(
        '-a', '--extra-patches-dir',
        help='Optional extra patches directory (default: None)',
        default=None,
        type=str
        )
    parser.add_argument(
        '-b', '--backports-dir',
        help=('Directory that contains patches for older Ubuntu versions '
              '(default: None)'),
        default=None,
        type=str
        )
    parser.add_argument(
        '-c', '--patches-blacklist',
        help='Patches which must not be applied',
        type=str,
        nargs='+'
        )
    parser.add_argument(
        '-z', '--submit-hashes-file',
        help='File in which to store the submit hashes',
        type=str,
        required=True
        )
    return parser.parse_args()


if __name__ == '__main__':
    _main()
