#!/usr/bin/env python3
# -*- coding: utf-8 -*-
'''
Automatically create tarball and submit it to launchpad.
'''

import os
import subprocess
import datetime
import shutil
import glob
import yaml
import git
import tarfile
import sys


def _run(command):
    '''Runs a given command on the command line and returns its output.
    '''
    # print(command)
    process = subprocess.Popen(
        command,
        shell=True,
        stdout=subprocess.PIPE,
        stderr=subprocess.PIPE,
        close_fds=True
        )
    output = process.stdout.read()[:-1]
    ret = process.wait()

    if ret != 0:
        sys.exit(
            '\nERROR: The command \n\n%s\n\nreturned a nonzero '
            'exit status. The error message is \n\n%s\n\n'
            'Abort.\n'
            % (command, process.stderr.read()[:-1])
            )
    return output


def _main():

    args = _parse_cmd_arguments()

    # Retrieve the directory of this script
    basedir = os.path.dirname(os.path.realpath(__file__))

    # Get package version.
    # Actually quite dangerous. The user may inject malicious code here.
    os.chdir(args.source_dir)
    package_version = subprocess.getoutput(args.version_getter).strip()

    # Get Debian info.
    if args.debian_dir:
        try:
            debian_repo = git.Repo(args.debian_dir + '../')
            debian_revision = str(debian_repo.rev_parse('HEAD'))
        except git.exc.InvalidGitRepositoryError:
            try:
                debian_repo = git.Repo(args.debian_dir)
                print('Fetching updates...')
                debian_repo.remotes.origin.pull()
                print('done.')
                debian_revision = str(debian_repo.rev_parse('HEAD'))
            except git.exc.InvalidGitRepositoryError:
                debian_revision = None
    else:
        debian_revision = None

    try:
        source_repo = git.Repo(args.source_dir)
    except git.exc.InvalidGitRepositoryError:
        source_repo = None

    has_tmp_commit = False
    if source_repo:
        print('Fetching updates...')
        source_repo.remotes.origin.pull()
        print('done.')
        # Build a version.
        if source_repo.is_dirty():
            if args.force:
                index = source_repo.index
                # Add all files with uncommitted changes to the index
                index.add([diff.a_blob.path for diff in index.diff(None)])
                # commit
                index.commit(
                    'temp commit',
                    author=git.Actor('launchpad-submitter', 'ls@wind')
                    )
                has_tmp_commit = True  # for later undoing of the commit
            else:
                raise RuntimeError(
                    'Uncommitted changes in the source repo. '
                    'Use -f to submit nonetheless.'
                    )
        source_revision = str(source_repo.rev_parse('HEAD'))
    else:
        source_revision = None

    if args.submit_hashes_file and os.path.isfile(args.submit_hashes_file):
        # File to store the HEAD command of the last push.
        revision_data = yaml.load_all(open(args.submit_hashes_file, 'r'))
        revision_dicts = []
        for doc in revision_data:
            revision_dicts.append(doc)
        is_uptodate = (
            source_revision == revision_dicts[0]['source revision'] and
            (not debian_revision or
                debian_revision == revision_dicts[0]['debian revision'])
            )

        if is_uptodate and not args.force:
            print('Latest version already submitted to launchpad.')
            return 0

    # Create a day-to-day version number of the form 4.3.1.2~201211230030.
    # For launchpad to accept new submissions, the string has to increment.
    now_str = datetime.datetime.now().strftime('%Y%m%d%H%M')
    version = package_version + '~' + now_str

    # Create the tarball.
    tarball_path = os.path.join('/tmp/', args.name + '.tar.gz')
    prefix = args.name + '-' + version
    print('Creating new archive %s...' % tarball_path)
    # Append the '/' to $PREFIX, otherwise this may be interpreted as an
    # ordinary filename-prefix.
    if source_repo:
        if source_repo.submodules:
            # Use <https://github.com/Kentzo/git-archive-all>
            os.chdir(args.source_dir)
            _run(
                'git-archive-all --prefix=%s %s' %
                (prefix + '/', tarball_path)
                )
        else:
            fh = open(tarball_path, 'wb')
            source_repo.archive(
                    fh,
                    prefix=prefix + '/',
                    format='tar.gz'
                    )
            fh.close()
    else:
        # Not a Git repo
        with tarfile.open(tarball_path, 'w:gz') as tar:
            tar.add(args.source_dir, arcname=prefix)

    print('done.')

    if has_tmp_commit:
        # undo temporary commit aka `git reset HEAD^`
        source_repo.git.reset('HEAD^')

    for ubuntu_release in args.ubuntu_releases:
        # Create empty directory of the form
        #     /tmp/trilinos/trusty/
        release_dir = os.path.join('/tmp', args.name, ubuntu_release)
        if os.path.exists(release_dir):
            shutil.rmtree(release_dir)
        # Use Python3's makedirs for recursive creation
        os.makedirs(release_dir, exist_ok=True)

        # Copy source tarball to
        #     /tmp/trilinos/trusty/trilinos_4.3.1.2~20121123.tar.gz
        tarball_name = '%s_%s.orig.tar.gz' % (args.name, version)
        shutil.copy2(tarball_path, os.path.join(release_dir, tarball_name))
        # Unpack the tarball
        os.chdir(release_dir)
        tar = tarfile.open(tarball_name)
        tar.extractall()
        tar.close()

        # # Cleaning Debian directory to avoid copy errors with invalid
        # # symlinks.
        #  TODO don't clean to make sure not to accidentally delete patches
        # os.chdir(args.debian_dir)
        # subprocess.check_call(['git', 'clean', '-f', '-d'])

        # Copy over the debian folder to
        #     /tmp/trilinos/trusty/debian/
        os.chdir(release_dir)
        if args.debian_dir:
            shutil.copytree(
                    args.debian_dir,
                    os.path.join(prefix, 'debian')
                    )
        else:
            # assert that the source tree contains a folder 'debian'
            assert(os.path.isdir(os.path.join(args.source_dir, 'debian')))

        # Patch the sources if necessary
        patch_file = os.path.join(basedir,
                                  args.name + '-ubuntu-backports',
                                  ubuntu_release + '.patch'
                                  )
        if os.path.isfile(patch_file):
            os.chdir(prefix)
            subprocess.check_call('patch -p1 < ' + patch_file, shell=True)

        # Optionally remove patches.
        if args.patches_blacklist:
            for sfile in ['patches/series', 'patches/ubuntu.series']:
                series_file = os.path.join(prefix, 'debian', sfile)
                if not os.path.isfile(series_file):
                    continue
                # list copies: <http://stackoverflow.com/a/2612815/353337>
                tmp_blacklist = list(args.patches_blacklist)
                tmp_file = os.path.join('/tmp/series.new')
                with open(series_file, 'r') as input:
                    with open(tmp_file, 'w') as output:
                        for line in input:
                            try:
                                k = tmp_blacklist.index(line.strip())
                                tmp_blacklist.pop(k)
                            except ValueError:
                                output.write(line)
                if tmp_blacklist:
                    raise ValueError('The patches %r are not in debian/series.'
                                     % tmp_blacklist
                                     )
                shutil.copy2(tmp_file, series_file)

        # Optionally add extra patches.
        if args.extra_patches_dir:
            if os.path.isabs(args.extra_patches_dir):
                source_dir = args.extra_patches_dir
            else:
                source_dir = os.path.join(basedir, args.extra_patches_dir)
            os.chdir(release_dir)
            dest_dir = os.path.join(prefix, 'debian', 'patches/')
            assert(os.path.isdir(dest_dir))
            files = glob.iglob(os.path.join(source_dir, '*.patch'))
            for file in files:
                if os.path.isfile(file):
                    shutil.copy2(file, dest_dir)
            # Concatenate the series files
            source_file = os.path.join(source_dir, 'series')
            dest_file = os.path.join(dest_dir, 'series')
            with open(dest_file, 'a') as outfile:
                with open(source_file) as infile:
                    outfile.write(infile.read())

        # Use the `-` as a separator (instead of `~` as it's often used) to
        # make sure that ${UBUNTU_RELEASE}x isn't part of the name. This makes
        # it possible to increment `x` and have launchpad recognize it as a new
        # version.
        full_version = version + '-' + ubuntu_release + args.resubmission
        if args.slot:
            chlog_version = args.slot + ':' + full_version
        else:
            chlog_version = full_version

        # Override changelog
        utcnow = datetime.datetime.utcnow()
        changelog = open(os.path.join(prefix, 'debian/changelog'), 'w')
        changelog.write('''%s (%s) %s; urgency=low

  * Initial release

 -- Nico Schl√∂mer <nico.schloemer@gmail.com>  %s'''
                        % (args.name, chlog_version,
                           ubuntu_release,
                           utcnow.strftime('%a, %d %b %Y %T +0000')
                           ))
        changelog.close()

        # Call debuild, the actual workhorse
        os.chdir(prefix)
        subprocess.check_call(
                ['debuild', '-p%s' % os.path.join(basedir, 'mygpg'), '-S']
                )

        # Submit to launchpad.
        os.chdir(os.pardir)
        for ppa in args.ppas:
            print()
            print('Uploading to PPA %s...' % ppa)
            print()
            subprocess.check_call([
                'dput',
                'ppa:%s' % ppa,
                '%s_%s_source.changes' % (args.name, full_version)
                ])
            # Remove the upload file so we can upload again to another ppa
            os.remove('%s_%s_source.ppa.upload'
                      % (args.name, full_version)
                      )

    if args.submit_hashes_file:
        # Store which revision we're pushing so we don't do it twice.
        data = {
            'source revision': source_revision,
            'debian revision': debian_revision
            }
        with open(args.submit_hashes_file, 'w') as outfile:
            outfile.write(yaml.dump(data, default_flow_style=False))

    return


def _parse_cmd_arguments():
    import argparse
    parser = argparse.ArgumentParser(description='Submit builds to launchpad.')
    parser.add_argument(
        '-n', '--name',
        type=str,
        required=True,
        help='package name'
        )
    parser.add_argument(
        '-r', '--resubmission',
        default=1,
        help='resubmission index (default: 1)'
        )
    parser.add_argument(
        '-s', '--source-dir',
        required=True,
        help='Directory of the package source'
        )
    parser.add_argument(
        '-d', '--debian-dir',
        help='Directory of the debian/ source'
        )
    parser.add_argument(
        '-u', '--ubuntu-releases',
        help='Ubuntu releases to build for',
        required=True,
        nargs='+'
        )
    parser.add_argument(
        '-p', '--ppas',
        help='PPAs to submit to',
        type=str,
        nargs='+',
        required=True
        )
    parser.add_argument(
        '-v', '--version-getter',
        help='Shell command for extracting the version number',
        type=str,
        required=True
        )
    parser.add_argument(
        '-l', '--slot',
        help='Slot for the package (default: None)',
        default=None,
        type=str
        )
    parser.add_argument(
        '-a', '--extra-patches-dir',
        help='Optional extra patches directory (default: None)',
        default=None,
        type=str
        )
    parser.add_argument(
        '-b', '--backports-dir',
        help=('Directory that contains patches for older Ubuntu versions '
              '(default: None)'),
        default=None,
        type=str
        )
    parser.add_argument(
        '-c', '--patches-blacklist',
        help='Patches which must not be applied',
        type=str,
        nargs='+'
        )
    parser.add_argument(
        '-z', '--submit-hashes-file',
        help='File in which to store the submit hashes',
        type=str,
        default=None
        )
    parser.add_argument(
        '-f', '--force',
        help='Force submission even if build is already uploaded',
        action='store_true',
        default=False
        )
    return parser.parse_args()


if __name__ == '__main__':
    _main()
