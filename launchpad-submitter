#!/usr/bin/env python3
# -*- coding: utf-8 -*-
'''
Automatically create tarball and submit it to launchpad.
'''

import argparse
import datetime
import git
# import git_archive_all
import os
import re
import shutil
import subprocess
import sys
import tarfile
import tempfile
import yaml


def _run(command, except_on_error=True):
    '''Runs a given command on the command line and returns its output.
    '''
    # print(command)
    process = subprocess.Popen(
        command,
        shell=True,
        stdout=subprocess.PIPE,
        stderr=subprocess.PIPE,
        close_fds=True
        )
    output = process.stdout.read()[:-1]
    ret = process.wait()

    if except_on_error and ret != 0:
        sys.exit(
            '\nERROR: The command \n\n%s\n\nreturned a nonzero '
            'exit status. The error message is \n\n%s\n\n'
            'Abort.\n'
            % (command, process.stderr.read()[:-1])
            )
    return output


def _update_patches(debian_dir, source_dir):
    '''debuild's patch apply doesn't allow fuzz, but fuzz is often what happens
    when applying a Debian patch to the master branch. `patch` itself is more
    robust, so use that here to update the Debian patches.
    '''
    print('Updating patches...')

    if os.path.isfile(os.path.join(debian_dir, 'patches', 'ubuntu.series')):
        series = os.path.join(debian_dir, 'patches', 'ubuntu.series')
    else:
        series = os.path.join(debian_dir, 'patches', 'series')

    with open(series, 'r') as f:
        content = f.readlines()

    if content:
        # copy the clean source tree to a tmp location
        tmp_dir = tempfile.mkdtemp()
        tmp_dir_a = os.path.join(tmp_dir, 'a')
        shutil.copytree(source_dir, os.path.join(tmp_dir, 'a'))
        os.chdir(tmp_dir)
        for line in content:
            filename = line.strip()
            if filename[0] == '#':
                # skip commented-out lines
                continue
            print('  Updating %s...' % filename)
            tmp_dir_b = os.path.join(tmp_dir, 'b')
            shutil.copytree(source_dir, tmp_dir_b)
            # patch the source
            patch_path = os.path.join(debian_dir, 'patches', filename)
            os.chdir(tmp_dir_b)
            _run('patch -p1 < %s' % patch_path)
            os.chdir(tmp_dir)
            _run(
                'diff -Naur %s %s > %s' % ('a', 'b', patch_path),
                except_on_error=False
                )

            shutil.rmtree(tmp_dir_b)
        shutil.rmtree(tmp_dir_a)

    print('done.')
    return


def _main():

    args = _parse_cmd_arguments()

    # Retrieve the directory of this script
    basedir = os.path.dirname(os.path.realpath(__file__))

    # Get Debian info.
    debian_revision = None
    if args.debian_dir:
        for directory in [args.debian_dir, args.debian_dir + '../']:
            try:
                debian_repo = git.Repo(directory)
                print('Fetching Debian updates...')
                debian_repo.remotes.origin.pull()
                print('done.')
                debian_revision = str(debian_repo.rev_parse('HEAD'))
            except git.exc.InvalidGitRepositoryError:
                # never mind
                pass

    try:
        source_repo = git.Repo(args.source_dir)
    except git.exc.InvalidGitRepositoryError:
        source_repo = None

    has_tmp_commit = False
    if source_repo:
        print('Fetching updates...')
        source_repo.remotes.origin.pull()
        print('done.')
        # Build a version.
        if source_repo.is_dirty():
            if args.force:
                index = source_repo.index
                # Add all files with uncommitted changes to the index
                index.add([diff.a_blob.path for diff in index.diff(None)])
                # commit
                index.commit(
                    'temp commit',
                    author=git.Actor('launchpad-submitter', 'ls@wind')
                    )
                has_tmp_commit = True  # for later undoing of the commit
            else:
                raise RuntimeError(
                    'Uncommitted changes in the source repo. '
                    'Use -f to submit nonetheless.'
                    )
        source_revision = str(source_repo.rev_parse('HEAD'))
    else:
        source_revision = None

    if args.submit_hashes_file and os.path.isfile(args.submit_hashes_file):
        # File to store the HEAD command of the last push.
        revision_data = yaml.load_all(open(args.submit_hashes_file, 'r'))
        revision_dicts = []
        for doc in revision_data:
            revision_dicts.append(doc)
        is_uptodate = (
            source_revision == revision_dicts[0]['source revision'] and
            (not debian_revision or
                debian_revision == revision_dicts[0]['debian revision'])
            )

        if is_uptodate and not args.force:
            print('Latest version already submitted to launchpad.')
            return 0

    # Extract the name from the changelog
    if args.debian_dir:
        changelog = os.path.join(args.debian_dir, 'changelog')
    elif args.source_dir:
        changelog = os.path.join(args.source_dir, 'debian', 'changelog')
    else:
        raise RuntimeError('Need source repo required.')

    with open(changelog, 'r') as f:
        first_line = f.readline()
        name_search = re.search('( *[^ ]+).*', first_line, re.IGNORECASE)
        if name_search:
            name = name_search.group(1)
        else:
            raise RuntimeError('Could not extract name from changelog.')

    # Create the tarball.
    tarball_path = os.path.join('/tmp/', name + '.tar.gz')
    prefix = name + '-' + args.version
    print('Creating new archive %s...' % tarball_path)
    if source_repo:
        if source_repo.submodules:
            # Use <https://github.com/Kentzo/git-archive-all>
            os.chdir(args.source_dir)
            # Append the '/' to $PREFIX, otherwise this may be interpreted as
            # an ordinary filename-prefix.
            subprocess.check_output(
                'git-archive-all --prefix=%s %s' %
                (prefix + '/', tarball_path)
                )
        else:
            fh = open(tarball_path, 'wb')
            source_repo.archive(
                    fh,
                    prefix=prefix + '/',
                    format='tar.gz'
                    )
            fh.close()
    elif args.source_dir:
        # Not a Git repo
        with tarfile.open(tarball_path, 'w:gz') as tar:
            tar.add(args.source_dir, arcname=prefix)
    else:
        # No source at all, just a dependency package
        pass

    print('done.')

    if has_tmp_commit:
        # undo temporary commit aka `git reset HEAD^`
        source_repo.git.reset('HEAD^')

    # # Cleaning Debian directory to avoid copy errors with invalid
    # # symlinks.
    #  TODO don't clean to make sure not to accidentally delete patches
    # os.chdir(args.debian_dir)
    # subprocess.check_call(['git', 'clean', '-f', '-d'])

    # Copy over the debian folder a temporary directory
    #     /tmp/trilinos/trusty/debian/
    if args.debian_dir:
        tmp_debian = tempfile.mkdtemp()
        shutil.rmtree(tmp_debian)
        shutil.copytree(args.debian_dir, tmp_debian)

    if args.debian_prepare:
        print('Execute \'%s\'...' % args.debian_prepare)
        os.chdir(tmp_debian)
        _run(args.debian_prepare)

    _update_patches(tmp_debian, args.source_dir)

    for ubuntu_release in args.ubuntu_releases:
        # Create empty directory of the form
        #     /tmp/trilinos/trusty/
        release_dir = os.path.join('/tmp', name, ubuntu_release)
        if os.path.exists(release_dir):
            shutil.rmtree(release_dir)
        # Use Python3's makedirs for recursive creation
        os.makedirs(release_dir, exist_ok=True)

        # Copy source tarball to
        #     /tmp/trilinos/trusty/trilinos_4.3.1.2~20121123.tar.gz
        tarball_name = '%s_%s.orig.tar.gz' % (name, args.version)
        shutil.copy2(tarball_path, os.path.join(release_dir, tarball_name))
        # Unpack the tarball
        os.chdir(release_dir)
        tar = tarfile.open(tarball_name)
        tar.extractall()
        tar.close()

        # Copy over Debian dir
        shutil.copytree(tmp_debian, os.path.join(prefix, 'debian'))

        os.chdir(release_dir)

        # Patch the sources if necessary
        patch_file = os.path.join(
                basedir,
                name + '-ubuntu-backports',
                ubuntu_release + '.patch'
                )
        if os.path.isfile(patch_file):
            os.chdir(prefix)
            subprocess.check_call('patch -p1 < ' + patch_file, shell=True)

        # Use the `-` as a separator (instead of `~` as it's often used) to
        # make sure that ${UBUNTU_RELEASE}x isn't part of the name. This makes
        # it possible to increment `x` and have launchpad recognize it as a new
        # version.
        full_version = args.version + '-' + ubuntu_release + \
            str(args.resubmission)
        if args.slot:
            chlog_version = args.slot + ':' + full_version
        else:
            chlog_version = full_version

        # Override changelog
        utcnow = datetime.datetime.utcnow()
        changelog = open(os.path.join(prefix, 'debian/changelog'), 'w')
        changelog.write('''%s (%s) %s; urgency=low

  * Initial release

 -- Nico SchlÃ¶mer <nico.schloemer@gmail.com>  %s'''
                        % (name, chlog_version,
                           ubuntu_release,
                           utcnow.strftime('%a, %d %b %Y %T +0000')
                           ))
        changelog.close()

        # Call debuild, the actual workhorse
        os.chdir(prefix)
        subprocess.check_call(
                ['debuild', '-p%s' % os.path.join(basedir, 'mygpg'), '-S',
                 '--lintian-opts', '-EvIL', '+pedantic']
                )

        # Submit to launchpad.
        os.chdir(os.pardir)
        if not args.dry:
            for ppa in args.ppas:
                print()
                print('Uploading to PPA %s...' % ppa)
                print()
                subprocess.check_call([
                    'dput',
                    'ppa:%s' % ppa,
                    '%s_%s_source.changes' % (name, full_version)
                    ])
                # Remove the upload file so we can upload again to another ppa
                os.remove('%s_%s_source.ppa.upload'
                          % (name, full_version)
                          )

    if args.submit_hashes_file:
        # Store which revision we're pushing so we don't do it twice.
        data = {
            'source revision': source_revision,
            'debian revision': debian_revision
            }
        with open(args.submit_hashes_file, 'w') as outfile:
            outfile.write(yaml.dump(data, default_flow_style=False))

    return


def _parse_cmd_arguments():
    parser = argparse.ArgumentParser(description='Submit builds to launchpad.')
    parser.add_argument(
        '-r', '--resubmission',
        default=1,
        help='resubmission index (default: 1)'
        )
    parser.add_argument(
        '-s', '--source-dir',
        help='Directory of the package source'
        )
    parser.add_argument(
        '-d', '--debian-dir',
        help='Directory of the debian/ source'
        )
    parser.add_argument(
        '-u', '--ubuntu-releases',
        help='Ubuntu releases to build for',
        required=True,
        nargs='+'
        )
    parser.add_argument(
        '-p', '--ppas',
        help='PPAs to submit to',
        type=str,
        nargs='+',
        required=True
        )
    parser.add_argument(
        '-v', '--version',
        help='Package version',
        type=str,
        required=True
        )
    parser.add_argument(
        '-e', '--debian-prepare',
        help='Shell command to execute in the debian folder before processing',
        type=str
        )
    parser.add_argument(
        '-l', '--slot',
        help='Slot for the package (default: None)',
        default=None,
        type=str
        )
    parser.add_argument(
        '-z', '--submit-hashes-file',
        help='File in which to store the submit hashes',
        type=str,
        default=None
        )
    parser.add_argument(
        '-f', '--force',
        help='Force submission even if build is already uploaded',
        action='store_true',
        default=False
        )
    parser.add_argument(
        '-y', '--dry',
        help='Dry run (do everything but the upload)',
        action='store_true',
        default=False
        )
    return parser.parse_args()


if __name__ == '__main__':
    _main()
