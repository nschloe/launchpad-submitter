diff --git a/packages/epetraext/src/inout/EpetraExt_mmio.cpp b/packages/epetraext/src/inout/EpetraExt_mmio.cpp
index 28b61a7..0e26448 100644
--- a/packages/epetraext/src/inout/EpetraExt_mmio.cpp
+++ b/packages/epetraext/src/inout/EpetraExt_mmio.cpp
@@ -41,7 +41,7 @@
 //@HEADER
 */
 
-/* 
+/*
 *   Matrix Market I/O library for ANSI C
 *
 *   See http://math.nist.gov/MatrixMarket for details.
@@ -71,20 +71,20 @@ int mm_read_unsymmetric_sparse(const char *fname, int *M_, int *N_, int *nz_,
     int i;
     double *val;
     int *I, *J;
- 
+
     if ((f = fopen(fname, "r")) == NULL)
             return -1;
- 
- 
+
+
     if (mm_read_banner(f, &matcode) != 0)
     {
         printf("mm_read_unsymetric: Could not process Matrix Market banner ");
         printf(" in file [%s]\n", fname);
         return -1;
     }
- 
- 
- 
+
+
+
     if ( !(mm_is_real(matcode) && mm_is_matrix(matcode) &&
             mm_is_sparse(matcode)))
     {
@@ -94,37 +94,37 @@ int mm_read_unsymmetric_sparse(const char *fname, int *M_, int *N_, int *nz_,
       fprintf(stderr, "Market Market type: [%s]\n",buffer);
         return -1;
     }
- 
+
     /* find out size of sparse matrix: M, N, nz .... */
- 
+
     if (mm_read_mtx_crd_size(f, &M, &N, &nz) !=0)
     {
         fprintf(stderr, "read_unsymmetric_sparse(): could not parse matrix size.\n");
         return -1;
     }
- 
+
     *M_ = M;
     *N_ = N;
     *nz_ = nz;
- 
+
     /* reseve memory for matrices */
- 
+
     //I = (int *) malloc(nz * sizeof(int));
     //J = (int *) malloc(nz * sizeof(int));
     //val = (double *) malloc(nz * sizeof(double));
- 
+
     I = new int[nz];
     J = new int[nz];
     val = new double[nz];
- 
+
     *val_ = val;
     *I_ = I;
     *J_ = J;
- 
+
     /* NOTE: when reading in doubles, ANSI C requires the use of the "l"  */
     /*   specifier as in "%lg", "%lf", "%le", otherwise errors will occur */
     /*  (ANSI C X3.159-1989, Sec. 4.9.6.2, p. 136 lines 13-15)            */
- 
+
     for (i=0; i<nz; i++)
     {
         fscanf(f, "%d %d %lg\n", &I[i], &J[i], &val[i]);
@@ -132,7 +132,7 @@ int mm_read_unsymmetric_sparse(const char *fname, int *M_, int *N_, int *nz_,
         J[i]--;
     }
     fclose(f);
- 
+
     return 0;
 }
 
@@ -141,7 +141,7 @@ int mm_is_valid(MM_typecode matcode)
     if (!mm_is_matrix(matcode)) return 0;
     if (mm_is_dense(matcode) && mm_is_pattern(matcode)) return 0;
     if (mm_is_real(matcode) && mm_is_hermitian(matcode)) return 0;
-    if (mm_is_pattern(matcode) && (mm_is_hermitian(matcode) || 
+    if (mm_is_pattern(matcode) && (mm_is_hermitian(matcode) ||
                 mm_is_skew(matcode))) return 0;
     return 1;
 }
@@ -150,24 +150,24 @@ int mm_read_banner(FILE *f, MM_typecode *matcode)
 {
     char line[MM_MAX_LINE_LENGTH];
     char banner[MM_MAX_TOKEN_LENGTH];
-    char mtx[MM_MAX_TOKEN_LENGTH]; 
+    char mtx[MM_MAX_TOKEN_LENGTH];
     char crd[MM_MAX_TOKEN_LENGTH];
     char data_type[MM_MAX_TOKEN_LENGTH];
     char storage_scheme[MM_MAX_TOKEN_LENGTH];
     char *p;
 
 
-    mm_clear_typecode(matcode);  
+    mm_clear_typecode(matcode);
 
-    if (fgets(line, MM_MAX_LINE_LENGTH, f) == NULL) 
+    if (fgets(line, MM_MAX_LINE_LENGTH, f) == NULL)
         return MM_PREMATURE_EOF;
 
-    if (sscanf(line, "%s %s %s %s %s", banner, mtx, crd, data_type, 
+    if (sscanf(line, "%s %s %s %s %s", banner, mtx, crd, data_type,
         storage_scheme) != 5)
         return MM_PREMATURE_EOF;
 
     for (p=mtx; *p!='\0'; *p=tolower(*p),p++);  /* convert to lower case */
-    for (p=crd; *p!='\0'; *p=tolower(*p),p++);  
+    for (p=crd; *p!='\0'; *p=tolower(*p),p++);
     for (p=data_type; *p!='\0'; *p=tolower(*p),p++);
     for (p=storage_scheme; *p!='\0'; *p=tolower(*p),p++);
 
@@ -192,7 +192,7 @@ int mm_read_banner(FILE *f, MM_typecode *matcode)
             mm_set_dense(matcode);
     else
         return MM_UNSUPPORTED_TYPE;
-    
+
 
     /* third field */
 
@@ -209,7 +209,7 @@ int mm_read_banner(FILE *f, MM_typecode *matcode)
         mm_set_integer(matcode);
     else
         return MM_UNSUPPORTED_TYPE;
-    
+
 
     /* fourth field */
 
@@ -226,7 +226,7 @@ int mm_read_banner(FILE *f, MM_typecode *matcode)
         mm_set_skew(matcode);
     else
         return MM_UNSUPPORTED_TYPE;
-        
+
 
     return 0;
 }
@@ -246,20 +246,20 @@ int mm_read_mtx_crd_size(FILE *f, int *M, int *N, int *nz )
     *M = *N = *nz = 0;
 
     /* now continue scanning until you reach the end-of-comments */
-    do 
+    do
     {
-        if (fgets(line,MM_MAX_LINE_LENGTH,f) == NULL) 
+        if (fgets(line,MM_MAX_LINE_LENGTH,f) == NULL)
             return MM_PREMATURE_EOF;
     }while (line[0] == '%');
 
     /* line[] is either blank or has M,N, nz */
     if (sscanf(line, "%d %d %d", M, N, nz) == 3)
         return 0;
-        
+
     else
     do
-    { 
-        num_items_read = fscanf(f, "%d %d %d", M, N, nz); 
+    {
+        num_items_read = fscanf(f, "%d %d %d", M, N, nz);
         if (num_items_read == EOF) return MM_PREMATURE_EOF;
     }
     while (num_items_read != 3);
@@ -276,20 +276,20 @@ int mm_read_mtx_crd_size(FILE *f, long long *M, long long *N, long long *nz )
     *M = *N = *nz = 0;
 
     /* now continue scanning until you reach the end-of-comments */
-    do 
+    do
     {
-        if (fgets(line,MM_MAX_LINE_LENGTH,f) == NULL) 
+        if (fgets(line,MM_MAX_LINE_LENGTH,f) == NULL)
             return MM_PREMATURE_EOF;
     }while (line[0] == '%');
 
     /* line[] is either blank or has M,N, nz */
     if (sscanf(line, "%lld %lld %lld", M, N, nz) == 3)
         return 0;
-        
+
     else
     do
-    { 
-        num_items_read = fscanf(f, "%lld %lld %lld", M, N, nz); 
+    {
+        num_items_read = fscanf(f, "%lld %lld %lld", M, N, nz);
         if (num_items_read == EOF) return MM_PREMATURE_EOF;
     }
     while (num_items_read != 3);
@@ -303,22 +303,22 @@ int mm_read_mtx_array_size(FILE *f, int *M, int *N)
     int num_items_read;
     /* set return null parameter values, in case we exit with errors */
     *M = *N = 0;
-	
+
     /* now continue scanning until you reach the end-of-comments */
-    do 
+    do
     {
-        if (fgets(line,MM_MAX_LINE_LENGTH,f) == NULL) 
+        if (fgets(line,MM_MAX_LINE_LENGTH,f) == NULL)
             return MM_PREMATURE_EOF;
     }while (line[0] == '%');
 
     /* line[] is either blank or has M,N, nz */
     if (sscanf(line, "%d %d", M, N) == 2)
         return 0;
-        
+
     else /* we have a blank line */
     do
-    { 
-        num_items_read = fscanf(f, "%d %d", M, N); 
+    {
+        num_items_read = fscanf(f, "%d %d", M, N);
         if (num_items_read == EOF) return MM_PREMATURE_EOF;
     }
     while (num_items_read != 2);
@@ -370,7 +370,7 @@ int mm_read_mtx_crd_data(FILE *f, int M, int N, int nz, int I[], int J[],
         return MM_UNSUPPORTED_TYPE;
 
     return 0;
-        
+
 }
 
 int mm_read_mtx_crd_entry(FILE *f, int *I, int *J,
@@ -396,7 +396,7 @@ int mm_read_mtx_crd_entry(FILE *f, int *I, int *J,
         return MM_UNSUPPORTED_TYPE;
 
     return 0;
-        
+
 }
 
 int mm_read_mtx_crd_entry(FILE *f, long long *I, long long *J,
@@ -422,7 +422,7 @@ int mm_read_mtx_crd_entry(FILE *f, long long *I, long long *J,
         return MM_UNSUPPORTED_TYPE;
 
     return 0;
-        
+
 }
 
 /************************************************************************
@@ -433,7 +433,7 @@ int mm_read_mtx_crd_entry(FILE *f, long long *I, long long *J,
                             (nz pairs of real/imaginary values)
 ************************************************************************/
 
-int mm_read_mtx_crd(char *fname, int *M, int *N, int *nz, int **I, int **J, 
+int mm_read_mtx_crd(char *fname, int *M, int *N, int *nz, int **I, int **J,
         double **val, MM_typecode *matcode)
 {
     int ret_code;
@@ -448,7 +448,7 @@ int mm_read_mtx_crd(char *fname, int *M, int *N, int *nz, int **I, int **J,
     if ((ret_code = mm_read_banner(f, matcode)) != 0)
         return ret_code;
 
-    if (!(mm_is_valid(*matcode) && mm_is_sparse(*matcode) && 
+    if (!(mm_is_valid(*matcode) && mm_is_sparse(*matcode) &&
             mm_is_matrix(*matcode)))
         return MM_UNSUPPORTED_TYPE;
 
@@ -468,7 +468,7 @@ int mm_read_mtx_crd(char *fname, int *M, int *N, int *nz, int **I, int **J,
     {
         //*val = (double *) malloc(*nz * 2 * sizeof(double));
         *val = new double[2*(*nz)];
-        ret_code = mm_read_mtx_crd_data(f, *M, *N, *nz, *I, *J, *val, 
+        ret_code = mm_read_mtx_crd_data(f, *M, *N, *nz, *I, *J, *val,
                 *matcode);
         if (ret_code != 0) return ret_code;
     }
@@ -476,14 +476,14 @@ int mm_read_mtx_crd(char *fname, int *M, int *N, int *nz, int **I, int **J,
     {
         //*val = (double *) malloc(*nz * sizeof(double));
         *val = new double[*nz];
-        ret_code = mm_read_mtx_crd_data(f, *M, *N, *nz, *I, *J, *val, 
+        ret_code = mm_read_mtx_crd_data(f, *M, *N, *nz, *I, *J, *val,
                 *matcode);
         if (ret_code != 0) return ret_code;
     }
 
     else if (mm_is_pattern(*matcode))
     {
-        ret_code = mm_read_mtx_crd_data(f, *M, *N, *nz, *I, *J, *val, 
+        ret_code = mm_read_mtx_crd_data(f, *M, *N, *nz, *I, *J, *val,
                 *matcode);
         if (ret_code != 0) return ret_code;
     }
@@ -498,7 +498,7 @@ int mm_write_banner(FILE *f, MM_typecode matcode)
 
   mm_typecode_to_str(matcode, buffer);
   int ret_code;
-  
+
   ret_code = fprintf(f, "%s %s\n", MatrixMarketBanner, buffer);
   //free(str);
   //delete [] str;
@@ -511,12 +511,12 @@ int mm_write_mtx_crd(char fname[], int M, int N, int nz, int I[], int J[],
     FILE *f;
     int i;
 
-    if (strcmp(fname, "stdout") == 0) 
+    if (strcmp(fname, "stdout") == 0)
         f = stdout;
     else
     if ((f = fopen(fname, "w")) == NULL)
         return MM_COULD_NOT_WRITE_FILE;
-    
+
     /* print banner followed by typecode */
     char buffer[MM_MAX_LINE_LENGTH];
     mm_typecode_to_str(matcode, buffer);
@@ -537,7 +537,7 @@ int mm_write_mtx_crd(char fname[], int M, int N, int nz, int I[], int J[],
     else
     if (mm_is_complex(matcode))
         for (i=0; i<nz; i++)
-            fprintf(f, "%d %d %20.16g %20.16g\n", I[i], J[i], val[2*i], 
+            fprintf(f, "%d %d %20.16g %20.16g\n", I[i], J[i], val[2*i],
                         val[2*i+1]);
     else
     {
@@ -549,7 +549,7 @@ int mm_write_mtx_crd(char fname[], int M, int N, int nz, int I[], int J[],
 
     return 0;
 }
-    
+
 
  void mm_typecode_to_str(MM_typecode matcode, char * buffer)
 {
@@ -557,48 +557,48 @@ int mm_write_mtx_crd(char fname[], int M, int N, int nz, int I[], int J[],
     int error =0;
 
     /* check for MTX type */
-    if (mm_is_matrix(matcode)) 
-        types[0] = MM_MTX_STR;
+    if (mm_is_matrix(matcode))
+        strcpy(types[0], MM_MTX_STR);
     else
         error=1;
 
     /* check for CRD or ARR matrix */
     if (mm_is_sparse(matcode))
-        types[1] = MM_SPARSE_STR;
+        strcpy(types[1], MM_SPARSE_STR);
     else
     if (mm_is_dense(matcode))
-        types[1] = MM_DENSE_STR;
+        strcpy(types[1], MM_DENSE_STR);
     else
         return;
 
     /* check for element data type */
     if (mm_is_real(matcode))
-        types[2] = MM_REAL_STR;
+        strcpy(types[2], MM_REAL_STR);
     else
     if (mm_is_complex(matcode))
-        types[2] = MM_COMPLEX_STR;
+        strcpy(types[2], MM_COMPLEX_STR);
     else
     if (mm_is_pattern(matcode))
-        types[2] = MM_PATTERN_STR;
+        strcpy(types[2], MM_PATTERN_STR);
     else
     if (mm_is_integer(matcode))
-        types[2] = MM_INT_STR;
+        strcpy(types[2], MM_INT_STR);
     else
         return;
 
 
     /* check for symmetry type */
     if (mm_is_general(matcode))
-        types[3] = MM_GENERAL_STR;
+        strcpy(types[3], MM_GENERAL_STR);
     else
     if (mm_is_symmetric(matcode))
-        types[3] = MM_SYMM_STR;
-    else 
+        strcpy(types[3], MM_SYMM_STR);
+    else
     if (mm_is_hermitian(matcode))
-        types[3] = MM_HERM_STR;
-    else 
+        strcpy(types[3], MM_HERM_STR);
+    else
     if (mm_is_skew(matcode))
-        types[3] = MM_SKEW_STR;
+        strcpy(types[3], MM_SKEW_STR);
     else
         return;
 
